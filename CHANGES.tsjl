               MAIN CHANGES FROM THE NETBSD TRUNK
                           2023-12-14


Kernel related changes
======================

	- drm2/: correction of memory computation;

	- config(1): it accepts now also context neutral "userconf"
	directives. These add the double quoted string given as
	argument to the userconf_kconf[] array. This array is
	interpreted by userconf(4) during startup (see below).
	Typically, MI userconf instructions should go in sys/conf/std
	like these ones:
#
# Userconf MI aliases.
#
userconf	"alias azerty qaQAwzWZaqAQ;m:MzwZWm,M?,;<..:>/"
# start to define an executable macro "fr"
#   - printing a message
userconf 	"alias -c fr print changing to pseudo-fr kbd mapping"
#   - mapping from def of azerty (-a azerty) and mapping * and -
userconf 	"alias -c fr kmap -a azerty `*~-"
#   - printing a hint: * and - are mapped at the upper left key
userconf	"alias -c fr p * and - are mapped to upper left ^2"
# Here, another macro: the drmkms alias is defined in MD code
userconf	"alias -c nodrmkms disable -a drmkms"

	and then in the kernel config, MD directives can be added for
	example to define drmkms (an alias; each instruction creates
	or adds to the definition):

# DRMKMS drivers
i915drmkms*	at pci? dev ? function ?
intelfb*	at intelfbbus?
userconf "alias drmkms i915drmkms*"

radeon* 	at pci? dev ? function ?
radeondrmkmsfb* at radeonfbbus?
userconf "alias drmkms radeon*"

#amdgpu*       at pci? dev ? function ?
#amdgpufb*     at amdgpufbbus?
 
nouveau*       at pci? dev ? function ?
nouveaufb*     at nouveaufbbus?
userconf "alias drmkms nouveau*"

	- cons(9): two new routines: cnmapreset() and cnmap() allow
	a "late" mapping of chars in startup console (works only with
	cnget*()), allowing a kind of keyboard mapping for use during
	this step;

	- userconf(4): in order for interaction and for the config(1)
	generated userconf_kconf[] array of instructions to be more
	useful, a lot of things have been added to userconf(4):

		o At init time, userconf interprets instructions
		(cmdlines) in userconf_kconf[] (generated by
		config(1)) before processing bootinfo directives and,
		perhaps, entering interactive session if the "-c" flag
		was passed to the kernel;

		o aliases: one can create aliases, including
		executable ones (macros). Userconf does its own
		alloc/free stuff for this;

		=> userconf_parse() thus handle taking definition of
		aliases and recursing for macros;

		o patterns: one can select devices using patterns.
		This works for change, disable, enable, find and list;

		o new built-ins:

			* aliases: create or add definition to an
			alias (that can be executable); allocated;

			* kmap: maps characters on the console
			(calling cons(9) added routines) allowing a
			kind of keyboard mapping for not US ASCII
			keyboards;

			* print: echos tokens including dereferencing
			of aliases;

			* unalias: delete an alias; freed;

			* vis: visualize (show) the definition of an
			alias (uninterpreted)---show and 'S' were not
			chosen to keep 'S' for "set" in the future; see
			FUTURE DIRECTIONS;

			* debug0: display config(1) added instructions
			parsed at startup time;

			* debug1: display debugging information about
			userconf memory and structures allocations;

			* debug2: display debugging information about
			userconf defined aliases;

		o Ergonomy: in order to limit the number of characters
		to be able to give:

			* input is case insensitive;

			* built-ins can be given with a single letter
			key (in all cases less one, this is the
			initial); a macro is at least two chars, 
			starting by a letter. Single letters are 
			reserved for built-ins;

			* no special character is needed for pattern
			or alias: a flag has to be given with a hyphen
			and a letter to change the interpretation of
			the next token (this was proposed by RVP).

		o FUTURE DIRECTIONS: I have reserved 'S' for set: a
		lot of things presently in MD boot could be put in
		MI userconf.

		o RATIONALE: in order to be able to enable/disable
		sets of devices or to give an easy command to type
		for keyboard (console at startup) without having to
		write MD code, the simplest is to be able to script
		it with aliases and let userconf interpret.
		
	- (partly DRM*) userconf can take also as a selector a pattern
	between slashes, for a fixed substring that can be anchored;

	- (DRM*) Specifying in sys/uvm/pmap_pvt.* that one function is
	only used by DRMKMS (drm2/).

	- Updating sys/dev/videomode/ to use the reference for
	monitors: VESA. This also corrects Mac modes (not specified
	in VESA DMT but that X11 got wrong).

Userland related changes
========================

	- Add the X11 DRMKMS man pages generated from rst (see
	netbsd-xsrc/drm-rst);

	- New version of inetd(8) addressing security issues (ignoring
	syntax errors that may lead to serve what was not intended to
	be served): adds an unprivileged syntax checker mode; extend
	the syntax; add a resilient mode that permits whether toi
	continue servicing a previous valid config (when trying to
	reload i.e. change it) or to fallback to a fixed name fallback
	one;
